{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"One-day BAM Workshop: Automatizing Data Management with PyBIS and the BAM Parser Infrastructure","text":"<p>Welcome to the one-day workshop at BAM to learn Python tools for Research Data Management (RDM) with openBIS. This page is organized into three parts (tutorials) presented during the workshop:</p> <ul> <li>Part 1 - Basic pyBIS Introduction: you will learn how to perform basic calls using pyBIS and about the available Entities in an openBIS instance.</li> <li>Part 2 - Advanced pyBIS Features: you will learn how to create new Entities, define their parent-child relationships, and automate searches and filters using pyBIS.</li> <li>Part 3 - BAM Parsers: you will learn how to automate data ingestion by creating new entities and their parent-child relationships using the BAM Parser Infrastructure.</li> </ul> <p>In order to work through the tutorials, you will need to install the following on your laptop:</p> <ol> <li>Visual Studio Code (VSCode)</li> <li>Miniforge3 with Python3.12</li> </ol> <p>We also recommend installing a few VSCode extensions, which will allow you to open and work with Python and Jupyter Notebooks:</p> <ul> <li>Python: https://marketplace.visualstudio.com/items?itemName=ms-python.python</li> <li>Jupyter: https://marketplace.visualstudio.com/items?itemName=ms-toolsai.jupyter</li> </ul>"},{"location":"#setting-up-vscode-with-python-in-windows","title":"Setting up VSCode with Python in Windows","text":"<p>Open VSCode and open a terminal. In order to run commands with Miniforge3 and Python, you need to make sure the terminal is running with <code>cmd</code>. In VSCode, do:</p> <pre><code>Ctrl+Shift+P \u2192 Terminal: Select Default Profile \u2192 Command Prompt\n</code></pre> <p></p> <p>After that, run the following command in the terminal:</p> <pre><code>C:\\Miniforge3\\Scripts\\conda.exe init cmd.exe\n</code></pre> <p>Note</p> <p>The path <code>C:\\Miniforge3\\Scripts</code> might be different in your case. As of January 2026, this is the default installation path for Miniforge3 on BAM laptops.</p> <p>After running this command in the terminal, close VSCode completely and reopen it.</p> <p>You can verify that the installation and paths are correct by running:</p> <pre><code>conda --version\n</code></pre> <p>or</p> <pre><code>where conda\n</code></pre> <p>You should get back either the conda version or the path where Miniforge3 has the <code>conda</code> executable located.</p> <p>Close VSCode completely again. When launching it once more and opening a new terminal, you should see <code>(base)</code> at the beginning of the terminal prompt. You can verify this by running:</p> <pre><code>echo %CONDA_DEFAULT_ENV%\n</code></pre> <p>Which should return <code>base</code>.</p> <p>If everything went well, you can also launch the interactive Python terminal:</p> <pre><code>python\n</code></pre> <p>You should see something similar to:</p> <pre><code>Python 3.12.12 | packaged by conda-forge | (main, Jan 26 2026, 23:38:32) [MSC v.1944 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\nCtrl click to launch VS Code Native REPL\n&gt;&gt;&gt;\n</code></pre>"},{"location":"#set-up-the-tutorial-workspace","title":"Set up the tutorial workspace","text":"<p>Now we can create a new folder in the directory where we will be working during this workshop, and then move into it:</p> <pre><code>mkdir tutorials\ncd tutorials\n</code></pre> <p>In this folder, you can create a new conda environment (answer <code>y</code> when prompted) with Python 3.12:</p> <pre><code>conda create -n pybis_tuto python=3.12\n</code></pre> <p>And activate it:</p> <pre><code>conda activate pybis_tuto\n</code></pre> <p>Next, you will need to install a few packages:</p> <pre><code>pip install pybis jupyter jupyterlab\n</code></pre> <p>Note</p> <p>In order to speed up the process, you can also pre-install uv in your laptop and run the command above using <code>uv</code>, i.e.: <pre><code>uv pip install pybis jupyter jupyterlab\n</code></pre></p> <p>You can verify that the installation works by running the interactive Python terminal and importing a specific pyBIS object:</p> <pre><code>python\n</code></pre> <p>Then, in the interactive Python terminal (without the <code>&gt;&gt;&gt;</code>), import:</p> <pre><code>&gt;&gt;&gt; from pybis import Openbis\n</code></pre> <p>If everything went well, after a few seconds you should be able to reference the <code>Openbis</code> class:</p> <pre><code>&gt;&gt;&gt; from pybis import Openbis\n&gt;&gt;&gt; Openbis\n&lt;class 'pybis.pybis.Openbis'&gt;\n</code></pre>"},{"location":"part1-basic_introduction/","title":"Part 1 - Basic pyBIS introduction","text":"<p>In openBIS, there are two main ways in which users can define and store metadata:</p> <ol> <li>Manual annotation of metadata via the Graphical User Interface (GUI).</li> <li>Automated data ingestion via an Application Programming Interface (API).</li> </ol> <p>In this part, you will learn the basics of the openBIS API in Python, also called pyBIS.</p> Tip <p>We recommend that readers launch a Jupyter Notebook in a Python environment with <code>pyBIS</code> installed, and run the commands shown throughout the following sections.</p>"},{"location":"part1-basic_introduction/#initial-setup-connecting-to-openbis","title":"Initial setup: connecting to openBIS","text":"<p>The first step when using pyBIS is to connect to the specific instance where you will work.</p> <p>We start by defining some variables:</p> <pre><code>URL = \"&lt;path-to-openbis-instance&gt;\"\nUSERNAME = \"&lt;your-bam-username&gt;\" \nPASSWORD = \"&lt;your-password&gt;\n</code></pre> <p>Warning</p> <p>You must not openly distribute the URL, USERNAME, and PASSWORD. In case you are working in open repositories (e.g., GitHub), make sure that these values are removed or anonymized before pushing content. There are other safer approaches (e.g., secret environments) which can help you manage your username and passwords securely.</p> <p>You can log in openbis with:</p> <pre><code>from pybis import Openbis\n\no = Openbis(URL)\no.login(USERNAME, PASSWORD)\n</code></pre> <p>After a few seconds, <code>o</code> will connect to the openBIS instance specified in <code>URL</code> using your credentials.</p> <p>You can check whether the session is active:</p> <pre><code>o.is_session_active()\n</code></pre> <p>Or check the openBIS version:</p> <pre><code>o.get_server_information().openbis_version\n</code></pre> <p>You can also define a personal access token (PAT):</p> <pre><code>PAT = o.get_or_create_personal_access_token(sessionName=\"My Tutorial Session\")\n</code></pre> <p>And use it for authentication instead of the username and password:</p> <pre><code>o = Openbis(URL)\no.set_token(PAT, save_token=True)\n</code></pre>"},{"location":"part1-basic_introduction/#exploring-available-openbis-folders-and-entities","title":"Exploring available openBIS folders and entities","text":"<p>In openBIS, data is organized following the structure: Space &gt; Projects &gt; Collections (optional) &gt; Objects. Spaces and Projects are folder-like structures used to organize research workflows. These workflows are described by Objects and by the parent-child relationships defined between them. Collections provide an optional way to group multiple objects under a common category. </p> <p>In addition, Datasets (i.e., entities containing raw data) can be attached to Objects or Collections to connect the raw data with the metadata describing it.</p> <p>In this sub-section, you will learn how to use pyBIS to explore the available Spaces, Projects, Collections, and Objects in the openBIS instance <code>o</code>. This knowledge will be useful later when building the data model with Objects and their parent-child relationships (see Part 2 - Advanced pyBIS features).</p>"},{"location":"part1-basic_introduction/#spaces-and-projects","title":"Spaces and Projects","text":"<p>You can get all the available Spaces in an openBIS instance by doing:</p> <pre><code>o.get_spaces()\n</code></pre> <p>To work within a specific Space, you can use its code:</p> <pre><code>my_space = o.get_spaces(\"&lt;SPACE-CODE&gt;\")\n</code></pre> <p>You can then retrieve a specific project from that space:</p> <pre><code>my_project = my_space.get_project(\"&lt;PROJECT-CODE&gt;\")\n</code></pre> <p>Similarly to Spaces, you can also list all projects availableS in an instance:</p> <pre><code>o.get_projects()\n</code></pre> <p>The variable <code>my_project</code> represrnts the Project container data can be stored.</p> <p>Hint</p> <p>Plural methods (<code>get_spaces</code>, <code>get_projects</code>) are called on the <code>Openbis</code> instance to retrieve the available folders in that instance. Singular methods (<code>get_space</code>, <code>get_project</code>) are then used to retrieve a specific folder from the returned results.</p>"},{"location":"part1-basic_introduction/#collections","title":"Collections","text":"<p>You can list all Collections in an instance, Space, or Project by respectively doing:</p> <pre><code>o.get_collections()\nmy_space.get_collections()\nmy_project.get_collections()\n</code></pre> <p>You can retrieve a specific Collection using its full path:</p> <pre><code>my_collection = o.get_collection(\"/&lt;SPACE-CODE&gt;/&lt;PROJECT-CODE&gt;/&lt;COLLECTION-CODE&gt;\")\n</code></pre> <p>If you do not know the path, you can inspect it either by calling <code>get_collections()</code> or by checking the Collection metadata in the openBIS web interface:</p> <p></p> <p>You can also retrieve a specific Collection using its <code>permID</code>:</p> <pre><code>my_collection = o.get_collection(permID)\n</code></pre>"},{"location":"part1-basic_introduction/#objects-and-datasets","title":"Objects and Datasets","text":"<p>Objects are accessed similarly to Collections, with the difference that Objects may also be grouped inside a Collection:</p> <pre><code>o.get_objects()\nmy_space.get_objects()\nmy_project.get_objects()\nmy_collection.get_objects()\n</code></pre> <p>You can also retrieve an Object using its path or <code>permID</code>:</p> <pre><code>my_object = o.get_object(\"/&lt;SPACE-CODE&gt;/&lt;PROJECT-CODE&gt;/&lt;COLLECTION-CODE&gt;/&lt;OBJECT-CODE&gt;\")\n# Alternative 1 (if the Object is directly under a Project):\n# my_object = o.get_object(\"/&lt;SPACE-CODE&gt;/&lt;PROJECT-CODE&gt;/&lt;OBJECT-CODE&gt;\")\n# Alternative 2:\n# my_object = o.get_object(permID)\n</code></pre> <p>Datasets follow the same pattern, using <code>get_datasets()</code> and <code>get_dataset()</code>. Datasets can be attached to Collections or Objects. You can download a specific dataset (e.g., defined by a <code>permID</code>) using:</p> <pre><code>o.get_dataset(permID).download()\n</code></pre> <p>You can also specify the destination directory:</p> <pre><code>o.get_dataset(permID).download(destination=\"my_downloads\", create_default_folders=False)\n</code></pre>"},{"location":"part2-advanced_features/","title":"Part 2 - Advanced pyBIS features","text":"<p>In this part, you will learn how to use pyBIS to create new Projects and Entities (Collections, Objects, Datasets), define parent-child relationships between Objects, and define advanced searches and filters in openBIS.</p> Tip <p>We recommend that readers launch a Jupyter Notebook in a Python environment with <code>pyBIS</code> installed, and run the commands shown throughout the following sections.</p>"},{"location":"part2-advanced_features/#creating-projects-and-other-entities","title":"Creating Projects and other Entities","text":"<p>You can create new Projects as follows:</p> <pre><code>new_project = o.new_project(\n    code=\"&lt;NEW-PROJECT-CODE&gt;\",\n    space=my_space,\n)\nnew_project.save()\n</code></pre> <p>Sucess</p> <p>Do not forget to call <code>save()</code> on newly created Projects or Entities after defining them to store them in openBIS.</p> <p>To create a new Collection, we need to know the <code>type</code> we want to define. Nevertheless, in the BAM Data Store we only use <code>COLLECTION</code> types is used for any Collection:</p> <pre><code>new_collection = o.new_collection(\n    code=\"&lt;NEW-COLLECTION-CODE&gt;\",\n    type=\"COLLECTION\",\n    project=new_project,\n)\nnew_collection.save()\n</code></pre>"},{"location":"part2-advanced_features/#creating-new-objects","title":"Creating new Objects","text":"<p>To create a new Object under a Collection or a Project, we need to know its <code>type</code> beforehand. This depends on the specific use case, as Object types are the main building blocks of data modeling in openBIS (see, e.g., the Conceptual Data Model in the BAM Wiki). </p> <p>You can find all available Object types in the BAM Masterdata repository or in the openBIS Admin UI.</p> <p>In this example, we assume that we are creating a new experimental step and assigning some dummy metadata to it. </p> <p>First, create the Object:</p> <pre><code>new_experimental_step = o.new_object(\n    code=\"&lt;NEW-OBJECT-CODE&gt;\",\n    type=\"EXPERIMENTAL_STEP\",\n    collection=new_collection,\n)\n</code></pre> <p>Note</p> <p>If the <code>code</code> attribute is left empty, openBIS will automatically assign one based on the definition of <code>EXPERIMENTAL_STEP</code>, followed by a four-digit number (see <code>generated_code_prefix</code> for <code>EXPERIMENTAL_STEP</code>).</p> <p>Each Object in openBIS has a set of assigned properties. A Property is a metadata field used to describe an Object. Properties can have different data types (e.g., string, integers, floats, etc.). One of the most relevant data types is CONTROLLEDVOCABULARY, which restricts values to a predefined set.</p> <p>You can list the available properties of an Object by doing:</p> <pre><code>new_experimental_step.props\n# in dictionary format:\n# new_experimental_step.props()\n</code></pre> <p>You can store metadata in the properties by passing a dictionary:</p> <pre><code>new_experimental_step.props = {\n    \"$name\": : \"trying out pybis\",\n    \"finished_flag\": False,\n}\nnew_experimental_step.save()\n</code></pre> <p>Note that:</p> <ul> <li>Each property has a defined data type. If the provided value does not match the expected type (e.g., <code>finished_flag</code> is a BOOLEAN, so passing <code>\"False\"</code> as a string will raise an error).</li> <li>Some properties are mandatory, while others are optional. Saving an Object with missing mandatory properties will result in an error.</li> <li>Properties can be passed directly at Object creation time using: <code>new_object(..., props={...})</code></li> <li>Alternatively, properties can be set individually, for example: <code>new_experimental_step[\"$name\"]: \"trying out pybis\"</code>.</li> </ul>"},{"location":"part2-advanced_features/#parent-child-relationships-between-objects","title":"Parent-child Relationships between Objects","text":"<p>Following the previous steps, imagine creating two additional experimental steps: <code>parent_experimental_step</code> and <code>child_experimental_step</code>.</p> <p>Now, you can create a parent-child relationship for <code>new_experimental_step</code>:</p> <pre><code>new_experimental_step.parents = parent_experimental_step\nnew_experimental_step.children = child_experimental_step\nnew_experimental_step.save()\n</code></pre> <p>You can also add parents or children using the following syntax:</p> <pre><code>parent_experimental_step.add_children(child_experimental_step)\nparent_experimental_step.save()\n</code></pre> <p>You can delete parent-child relationships as well:</p> <pre><code>parent_experimental_step.del_children(child_experimental_step)\nparent_experimental_step.save()\n</code></pre>"},{"location":"part2-advanced_features/#attaching-datasets","title":"Attaching datasets","text":"<p>Datasets can be created similarly to other entities, with the difference that files must be attached. In the BAM Data Store, only <code>RAW_DATA</code> is used as the Dataset type:</p> <pre><code>new_dataset = o.new_dataset(\n    type=\"RAW_DATA\",\n    object=new_experimental_step,\n    files=[\"path-to-some-file\"]\n)\nnew_dataset.save()\n</code></pre> <p>Datasets can also be deleted:</p> <pre><code>new_dataset.delete(reason=\"We finished with the example\")\n</code></pre>"},{"location":"part2-advanced_features/#search-and-filters","title":"Search and filters","text":"<p>In Part 1, you learned how to explore what is available in the openBIS instance. More advanced searches and filters are also possible, such as filtering Objects based on metadata values or numerical threshold.</p> <p>In this sub-section, we focus on filtering Objects.</p> <p>Methods such as <code>get_objects()</code> typically return all the matching Objects in an instance. For efficiency, it is often better to retrieve results in batches. This can be achieved using the <code>count</code> and <code>start_with</code> parameters:</p> <pre><code>start_with = 3 \n\nexperimental_steps = o.get_objects(\n    type=\"EXPERIMENTAL_STEP\",\n    count=6, \n    start_with=start_with,\n)\n</code></pre> <p>Here, <code>start_with</code> specifies the index at which the result list starts, while <code>count</code> defines how many Objects are returned. The <code>type</code> parameter restricts the search to a specific Object type (in this case, <code>EXPERIMENTAL_STEP</code>).</p> <pre><code>for step in experimental_steps:\n    print(f\"Experimental step: {step.code}\")\n</code></pre> <p>You can also retrieve Objects whose properties match certain values:</p> <pre><code>o.get_objects(\n    where={\"$name\": \"* &lt;name-we-want-to-find&gt;\"},\n    props=[\"$name\"],\n)\n</code></pre> <p>Here, the <code>props</code> parameter ensures that <code>$name</code> is included in the returned results.</p> <p>Mathematical comparison operators (<code>&gt;</code>, <code>&lt;</code>, <code>=</code>, <code>&gt;=</code>, <code>&lt;=</code>) can also be used:</p> <pre><code>o.get_objects(registrationdate=\"&gt;2023-07-21\")\n</code></pre> <p>And even more complex searches:</p> <pre><code>o.get_objects(\n    space=\"MY_*\",  # spaces starting with MY_\n    type=\"*_STEP*\",  # objects types containing _STEP\n    withParents=\"*\",  # objects having any parents\n    withChildren=[\n        \"/MY_SPACE/MY_PROJECT/MY_COLLECTION/SAMPLE*\",\n    ],  # objects having children with codes starting with SAMPLE\n)\n</code></pre>"},{"location":"part3-bam_parsers/","title":"Part 3 - BAM Parsers","text":"<p>Up to this point, you have learned how to work with pyBIS to explore, create, and search metadata in openBIS. Despite their inmense usefulness, individual pyBIS scripts suffer from maintainability and discoverability issues: two different people can easily create different pyBIS scripts that implement the same functionality.</p> <p>For this reason, and specifically in the context of creating new Objects and defining their relationships (i.e., automated data ingestion in openBIS), the BAM Data Store decided to define a common interface in the BAM Masterdata GitHub repository. This interface allows you to create parser scripts in a standardized way.</p> <p>When deciding whether to write a standalone pyBIS script or to use the BAM Parser Infrastructure, you should ask yourself the following questions:</p> <ol> <li>Is this script used to read metadata from files that are continously being produced in my laboratory?</li> <li>Is this script going to be used by other people?</li> <li>Does the logic I implemented go beyond my specific use case?</li> </ol> <p>If the answer to all these questions is yes, then you should create a parser following the BAM Parser Infrastructure and its documentation. In particular, we recommend starting with:</p> <ul> <li>Tutorial: Parsing data using BAM Masterdata.</li> <li>How-to: Create a New Parser.</li> </ul> <p>For a deeper understanding, you can also read:</p> <ul> <li>Explanation: Parsing and ETL Structure in the Parser App.</li> </ul> Why use this instead of pyBIS directly? <p>Beyond the issue of duplicated scripts, the BAM Parser Infrastructure allows you to focus primarily on parsing and structuring metadata for Objects, rather than on repeatedly implementing connection logic, authentication, error handling, and object creation workflows. In the future, we plan to deploy a dedicated Parser App that will load and execute these parsers through a user-friendly interface. Parsers that do not follow the BAM Parser Infrastructure will not be integrable into this application.</p>"}]}